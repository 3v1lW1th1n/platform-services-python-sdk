# coding: utf-8

# (C) Copyright IBM Corp. 2020.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
No description provided (generated by Openapi Generator
https://github.com/openapitools/openapi-generator)
"""

from enum import Enum
from typing import BinaryIO, Dict, List
import json

from ibm_cloud_sdk_core import BaseService, DetailedResponse
from ibm_cloud_sdk_core.authenticators.authenticator import Authenticator
from ibm_cloud_sdk_core.get_authenticator import get_authenticator_from_environment
from ibm_cloud_sdk_core.utils import convert_list, convert_model

from .common import get_sdk_headers

##############################################################################
# Service
##############################################################################

class CaseManagementV1(BaseService):
    """The Case Management V1 service."""

    DEFAULT_SERVICE_URL = 'https://support-center.cloud.ibm.com/'
    DEFAULT_SERVICE_NAME = 'case_management'

    @classmethod
    def new_instance(cls,
                     service_name: str = DEFAULT_SERVICE_NAME,
                    ) -> 'CaseManagementV1':
        """
        Return a new client for the Case Management service using the specified
               parameters and external configuration.
        """
        authenticator = get_authenticator_from_environment(service_name)
        service = cls(
            authenticator
            )
        service.configure_service(service_name)
        return service

    def __init__(self,
                 authenticator: Authenticator = None,
                ) -> None:
        """
        Construct a new client for the Case Management service.

        :param Authenticator authenticator: The authenticator specifies the authentication mechanism.
               Get up to date information from https://github.com/IBM/python-sdk-core/blob/master/README.md
               about initializing the authenticator of your choice.
        """
        BaseService.__init__(self,
                             service_url=self.DEFAULT_SERVICE_URL,
                             authenticator=authenticator)


    #########################
    # Case Management
    #########################


    def get_cases(self, *, offset: int = None, limit: int = None, search: str = None, sort: str = None, status: List[str] = None, fields: List[str] = None, **kwargs) -> DetailedResponse:
        """
        Get cases in account.

        Get cases in the account which is specified by the content of the IAM token.

        :param int offset: (optional) Number of cases should be skipped.
        :param int limit: (optional) Number of cases should be returned.
        :param str search: (optional) String that a case might contain.
        :param str sort: (optional) Sort field and direction. If omitted, default
               to descending of updated date. Prefix "~" signifies sort in descending.
        :param List[str] status: (optional) Case status filter.
        :param List[str] fields: (optional) Selected fields of interest instead of
               the entire case information.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CaseCollection` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='get_cases')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'search': search,
            'sort': sort,
            'status': convert_list(status),
            'fields': convert_list(fields)
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/v1/cases'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_case(self, *, type: str = None, subject: str = None, description: str = None, severity: int = None, eu: 'EuPayload' = None, offering: 'OfferingPayload' = None, resources: List['Resource'] = None, watchlist: List['User'] = None, invoice_number: str = None, sla_credit_request: bool = None, **kwargs) -> DetailedResponse:
        """
        Create a case.

        Create a case in the account.

        :param str type: (optional) the case type.
        :param str subject: (optional) Subject of the case.
        :param str description: (optional) Detailed description of the issue.
        :param int severity: (optional) the severity associated with the case (1 -
               4).
        :param EuPayload eu: (optional) Specify if the case should be treated as EU
               regulated. Only one of the following properties is required. Call EU
               support utility endpoint to determine which property must be specified for
               your account.
        :param OfferingPayload offering: (optional) The offering of a case to be
               created.
        :param List[Resource] resources: (optional) List of resources to attach to
               case. If attaching Classic IaaS devices use type and id fields if Cloud
               Resource Name (CRN) is unavialable. Otherwise pass the resource CRN. The
               resource list must be consistent with the value selected for the resource
               offering.
        :param List[User] watchlist: (optional) User IDs in the watchlist.
        :param str invoice_number: (optional) Invoice number of "Billing and
               Invoice" case type.
        :param bool sla_credit_request: (optional) Flag to indicate if case is for
               an Service Level Agreement (SLA) credit request.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Case` object
        """

        if eu is not None:
            eu = convert_model(eu)
        if offering is not None:
            offering = convert_model(offering)
        if resources is not None:
            resources = [ convert_model(x) for x in resources ]
        if watchlist is not None:
            watchlist = [ convert_model(x) for x in watchlist ]
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='create_case')
        headers.update(sdk_headers)

        data = {
            'type': type,
            'subject': subject,
            'description': description,
            'severity': severity,
            'eu': eu,
            'offering': offering,
            'resources': resources,
            'watchlist': watchlist,
            'invoice_number': invoice_number,
            'sla_credit_request': sla_credit_request
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/v1/cases'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_case(self, case_number: str, *, fields: List[str] = None, **kwargs) -> DetailedResponse:
        """
        Get a case in account.

        Get a case in the account that is specified by the case number.

        :param str case_number: Unique identifier of a case.
        :param List[str] fields: (optional) Selected fields of interest instead of
               the entire case information.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Case` object
        """

        if case_number is None:
            raise ValueError('case_number must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='get_case')
        headers.update(sdk_headers)

        params = {
            'fields': convert_list(fields)
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/v1/cases/{0}'.format(*self.encode_path_vars(case_number))
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def update_case_status(self, case_number: str, action: str, *, comment: str = None, resolution_code: int = None, **kwargs) -> DetailedResponse:
        """
        Update case status.

        Mark the case as resolved or unresolved, or accept the provided resolution.

        :param str case_number: Unique identifier of a case.
        :param str action: the action to perform on the case.
        :param str comment: (optional) a comment to be associated with the updated
               status.
        :param int resolution_code: (optional) * 1: Client error
               * 2: Defect found with Component/Service
               * 3: Documentation Error
               * 4: Sollution found in forums
               * 5: Solution found in public Documentation
               * 6: Solution no longer required
               * 7: Solution provided by IBM outside of support case
               * 8: Solution provided by IBM support engineer.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Case` object
        """

        if case_number is None:
            raise ValueError('case_number must be provided')
        if action is None:
            raise ValueError('action must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='update_case_status')
        headers.update(sdk_headers)

        data = {
            'action': action,
            'comment': comment,
            'resolution_code': resolution_code
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/v1/cases/{0}/status'.format(*self.encode_path_vars(case_number))
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def add_comment(self, case_number: str, comment: str, **kwargs) -> DetailedResponse:
        """
        Add comment to case.

        Add a comment to a case.

        :param str case_number: Unique identifier of a case.
        :param str comment: the comment to be added to the case.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Comment` object
        """

        if case_number is None:
            raise ValueError('case_number must be provided')
        if comment is None:
            raise ValueError('comment must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='add_comment')
        headers.update(sdk_headers)

        data = {
            'comment': comment
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/v1/cases/{0}/comments'.format(*self.encode_path_vars(case_number))
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def add_watchlist(self, case_number: str, *, watchlist: List['UserIdAndRealm'] = None, **kwargs) -> DetailedResponse:
        """
        Add users to watchlist of case.

        Add users to the watchlist of case. By adding a user to the watchlist of the case,
        you are granting them read and write permissions, so the user can view the case,
        receive updates, and make updates to the case. Note that the user must be in the
        account to be added to the watchlist.

        :param str case_number: Unique identifier of a case.
        :param List[UserIdAndRealm] watchlist: (optional) List of users to be added
               or removed from the watchlist of a case.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AddWatchlistResults` object
        """

        if case_number is None:
            raise ValueError('case_number must be provided')
        if watchlist is not None:
            watchlist = [ convert_model(x) for x in watchlist ]
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='add_watchlist')
        headers.update(sdk_headers)

        data = {
            'watchlist': watchlist
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/v1/cases/{0}/watchlist'.format(*self.encode_path_vars(case_number))
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def remove_watchlist(self, case_number: str, *, watchlist: List['UserIdAndRealm'] = None, **kwargs) -> DetailedResponse:
        """
        Remove users from watchlist of case.

        Remove users from the watchlist of a case.

        :param str case_number: Unique identifier of a case.
        :param List[UserIdAndRealm] watchlist: (optional) List of users to be added
               or removed from the watchlist of a case.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `List[User]` result
        """

        if case_number is None:
            raise ValueError('case_number must be provided')
        if watchlist is not None:
            watchlist = [ convert_model(x) for x in watchlist ]
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='remove_watchlist')
        headers.update(sdk_headers)

        data = {
            'watchlist': watchlist
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/v1/cases/{0}/watchlist'.format(*self.encode_path_vars(case_number))
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def add_resource(self, case_number: str, *, crn: str = None, name: str = None, type: str = None, id: int = None, note: str = None, **kwargs) -> DetailedResponse:
        """
        Add a resource to case.

        Add a resource to case by specifying the Cloud Resource Name (CRN), or id and type
        if attaching a class iaaS resource.

        :param str case_number: Unique identifier of a case.
        :param str crn: (optional) Cloud Resource Name of the resource.
        :param str name: (optional) Name of the resource.
        :param str type: (optional) Only used to attach Classic IaaS devices which
               have no CRN.
        :param int id: (optional) Only used to attach Classic IaaS devices which
               have no CRN. Id of Classic IaaS device.
        :param str note: (optional) A note about this resource.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Resource` object
        """

        if case_number is None:
            raise ValueError('case_number must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='add_resource')
        headers.update(sdk_headers)

        data = {
            'crn': crn,
            'name': name,
            'type': type,
            'id': id,
            'note': note
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/v1/cases/{0}/resources'.format(*self.encode_path_vars(case_number))
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def upload_file(self, case_number: str, file: BinaryIO, *, file_content_type: str = None, **kwargs) -> DetailedResponse:
        """
        Add attachment(s) to case.

        You can add attachments to a case to provide more information for the support team
        about the issue that you're experiencing.

        :param str case_number: Unique identifier of a case.
        :param BinaryIO file: file of supported types, 8MB in size limit.
        :param str file_content_type: (optional) The content type of file.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Attachment` object
        """

        if case_number is None:
            raise ValueError('case_number must be provided')
        if file is None:
            raise ValueError('file must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='upload_file')
        headers.update(sdk_headers)

        form_data = []
        form_data.append(('file', (None, file, file_content_type or 'application/octet-stream')))

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/v1/cases/{0}/attachments'.format(*self.encode_path_vars(case_number))
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       files=form_data)

        response = self.send(request)
        return response


    def download_file(self, case_number: str, file_id: str, **kwargs) -> DetailedResponse:
        """
        Download an attachment.

        Download an attachment from a case.

        :param str case_number: Unique identifier of a case.
        :param str file_id: Unique identifier of a file.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `BinaryIO` result
        """

        if case_number is None:
            raise ValueError('case_number must be provided')
        if file_id is None:
            raise ValueError('file_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='download_file')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/v1/cases/{0}/attachments/{1}'.format(*self.encode_path_vars(case_number, file_id))
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def delete_file(self, case_number: str, file_id: str, **kwargs) -> DetailedResponse:
        """
        Remove attachment from case.

        Remove an attachment from a case.

        :param str case_number: Unique identifier of a case.
        :param str file_id: Unique identifier of a file.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `DeleteFileResponse` object
        """

        if case_number is None:
            raise ValueError('case_number must be provided')
        if file_id is None:
            raise ValueError('file_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='delete_file')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/v1/cases/{0}/attachments/{1}'.format(*self.encode_path_vars(case_number, file_id))
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response

    #########################
    # Utilities
    #########################


    def get_eu_support(self, **kwargs) -> DetailedResponse:
        """
        Shows how to mark case as EU supported.

        Shows how an account can mark a case as EU supported.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `EuSupport` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='get_eu_support')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/utilities/v1/eu-support'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def get_technical_offerings(self, **kwargs) -> DetailedResponse:
        """
        Get offerings.

        Get offerings used in technical cases.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TechnicalOfferingsResponse` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='get_technical_offerings')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/utilities/v1/offerings/technical'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def get_resolution_codes(self, **kwargs) -> DetailedResponse:
        """
        Get resolution code values.

        Get the resolution code values used in "Update Status API".

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ResolutionCodesResponse` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='get_resolution_codes')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/utilities/v1/constants/resolution-codes'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def get_statuses(self, **kwargs) -> DetailedResponse:
        """
        Get status values.

        Get the status values used in case filtering.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `StatusesResponse` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME, service_version='V1', operation_id='get_statuses')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/case-management/utilities/v1/constants/statuses'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


class GetCasesEnums:
    """
    Enums for get_cases parameters.
    """

    class Status(Enum):
        """
        Case status filter.
        """
        NEW = 'new'
        IN_PROGRESS = 'in_progress'
        WAITING_ON_CLIENT = 'waiting_on_client'
        RESOLUTION_PROVIDED = 'resolution_provided'
        RESOLVED = 'resolved'
        CLOSED = 'closed'
    class Fields(Enum):
        """
        Selected fields of interest instead of the entire case information.
        """
        NUMBER = 'number'
        SHORT_DESCRIPTION = 'short_description'
        DESCRIPTION = 'description'
        CREATED_AT = 'created_at'
        CREATED_BY = 'created_by'
        UPDATED_AT = 'updated_at'
        UPDATED_BY = 'updated_by'
        CONTACT = 'contact'
        CONTACT_TYPE = 'contact_type'
        STATUS = 'status'
        SEVERITY = 'severity'
        SUPPORT_TIER = 'support_tier'
        RESOLUTION = 'resolution'
        CLOSE_NOTES = 'close_notes'
        INVOICE_NUMBER = 'invoice_number'
        EU = 'eu'
        WATCHLIST = 'watchlist'
        ATTACHMENTS = 'attachments'
        RESOURCES = 'resources'
        COMMENTS = 'comments'
        OFFERING = 'offering'


##############################################################################
# Models
##############################################################################


class OfferingItemType():
    """
    the offering type.

    :attr str group: (optional) the offering type's group.
    :attr str key: (optional) the offering type's key value.
    """

    def __init__(self, *, group: str = None, key: str = None) -> None:
        """
        Initialize a OfferingItemType object.

        :param str group: (optional) the offering type's group.
        :param str key: (optional) the offering type's key value.
        """
        self.group = group
        self.key = key

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'OfferingItemType':
        """Initialize a OfferingItemType object from a json dictionary."""
        args = {}
        if 'group' in _dict:
            args['group'] = _dict.get('group')
        if 'key' in _dict:
            args['key'] = _dict.get('key')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a OfferingItemType object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'group') and self.group is not None:
            _dict['group'] = self.group
        if hasattr(self, 'key') and self.key is not None:
            _dict['key'] = self.key
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this OfferingItemType object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'OfferingItemType') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'OfferingItemType') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    
    class GroupEnum(Enum):
        """
        the offering type's group.
        """
        CRN_SERVICE_NAME = "crn_service_name"
        CATEGORY = "category"


class OfferingPayloadType():
    """
    Resource offering type.

    :attr str group: (optional) the offering type's group.
    :attr str key: (optional) the offering type's key.
    :attr str id: (optional) the offering type's identifier.
    :attr str kind: (optional) the offering type's kind.
    """

    def __init__(self, *, group: str = None, key: str = None, id: str = None, kind: str = None) -> None:
        """
        Initialize a OfferingPayloadType object.

        :param str group: (optional) the offering type's group.
        :param str key: (optional) the offering type's key.
        :param str id: (optional) the offering type's identifier.
        :param str kind: (optional) the offering type's kind.
        """
        self.group = group
        self.key = key
        self.id = id
        self.kind = kind

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'OfferingPayloadType':
        """Initialize a OfferingPayloadType object from a json dictionary."""
        args = {}
        if 'group' in _dict:
            args['group'] = _dict.get('group')
        if 'key' in _dict:
            args['key'] = _dict.get('key')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'kind' in _dict:
            args['kind'] = _dict.get('kind')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a OfferingPayloadType object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'group') and self.group is not None:
            _dict['group'] = self.group
        if hasattr(self, 'key') and self.key is not None:
            _dict['key'] = self.key
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'kind') and self.kind is not None:
            _dict['kind'] = self.kind
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this OfferingPayloadType object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'OfferingPayloadType') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'OfferingPayloadType') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    
    class GroupEnum(Enum):
        """
        the offering type's group.
        """
        CRN_SERVICE_NAME = "crn_service_name"
        CATEGORY = "category"


class AddWatchlistResults():
    """
    the response returned by the `add_watchlist` operation.

    :attr List[User] added: (optional) List of successfully added user IDs.
    :attr List[User] failed: (optional) List of failed-to-add user IDs.
    """

    def __init__(self, *, added: List['User'] = None, failed: List['User'] = None) -> None:
        """
        Initialize a AddWatchlistResults object.

        :param List[User] added: (optional) List of successfully added user IDs.
        :param List[User] failed: (optional) List of failed-to-add user IDs.
        """
        self.added = added
        self.failed = failed

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AddWatchlistResults':
        """Initialize a AddWatchlistResults object from a json dictionary."""
        args = {}
        if 'added' in _dict:
            args['added'] = [User.from_dict(x) for x in _dict.get('added')]
        if 'failed' in _dict:
            args['failed'] = [User.from_dict(x) for x in _dict.get('failed')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AddWatchlistResults object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'added') and self.added is not None:
            _dict['added'] = [x.to_dict() for x in self.added]
        if hasattr(self, 'failed') and self.failed is not None:
            _dict['failed'] = [x.to_dict() for x in self.failed]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AddWatchlistResults object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AddWatchlistResults') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AddWatchlistResults') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class Attachment():
    """
    Details of an attachment.

    :attr str id: (optional) Unique identifier of the attachment in database.
    :attr str filename: (optional) Name of the attachment.
    :attr int size_in_bytes: (optional) Size of the attachment in bytes.
    :attr str created_at: (optional) Date time of uploading.
    :attr str url: (optional) URL of the attachment used to download.
    """

    def __init__(self, *, id: str = None, filename: str = None, size_in_bytes: int = None, created_at: str = None, url: str = None) -> None:
        """
        Initialize a Attachment object.

        :param str id: (optional) Unique identifier of the attachment in database.
        :param str filename: (optional) Name of the attachment.
        :param int size_in_bytes: (optional) Size of the attachment in bytes.
        :param str created_at: (optional) Date time of uploading.
        :param str url: (optional) URL of the attachment used to download.
        """
        self.id = id
        self.filename = filename
        self.size_in_bytes = size_in_bytes
        self.created_at = created_at
        self.url = url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Attachment':
        """Initialize a Attachment object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'filename' in _dict:
            args['filename'] = _dict.get('filename')
        if 'size_in_bytes' in _dict:
            args['size_in_bytes'] = _dict.get('size_in_bytes')
        if 'created_at' in _dict:
            args['created_at'] = _dict.get('created_at')
        if 'url' in _dict:
            args['url'] = _dict.get('url')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Attachment object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'filename') and self.filename is not None:
            _dict['filename'] = self.filename
        if hasattr(self, 'size_in_bytes') and self.size_in_bytes is not None:
            _dict['size_in_bytes'] = self.size_in_bytes
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = self.created_at
        if hasattr(self, 'url') and self.url is not None:
            _dict['url'] = self.url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Attachment object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Attachment') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Attachment') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class Case():
    """
    a case object.

    :attr str number: (optional) Number/ID of the case.
    :attr str short_escription: (optional) A short description of what the case is
          about.
    :attr str description: (optional) A full description of what the case is about.
    :attr str created_at: (optional) Date time of case creation in UTC.
    :attr User created_by: (optional) Case creator.
    :attr str updated_at: (optional) Date time of the last update on the case in
          UTC.
    :attr User updated_by: (optional) Person who makes the most recent update to the
          case.
    :attr str contact_type: (optional) Name of the console to interact with the
          contact.
    :attr User contact: (optional) Person who reported the case.
    :attr str status: (optional) Status of the case.
    :attr float severity: (optional) The severity of the case.
    :attr str support_tier: (optional) Support tier of the account.
    :attr str resolution: (optional) Standard reasons of resolving case.
    :attr str close_notes: (optional) Notes of case closing.
    :attr Eu eu: (optional) Specifies if the case should be treated as EU regulated.
    :attr List[User] watchlist: (optional) User IDs in the watchlist.
    :attr List[Attachment] attachments: (optional) List of attachments/files of the
          case.
    :attr Offering offering: (optional) A catalog offering associated with a case.
    :attr List[Resource] resources: (optional) List of attached resources.
    :attr List[Comment] comments: (optional) List of comments/updates sorted in
          chronological order.
    """

    def __init__(self, *, number: str = None, short_escription: str = None, description: str = None, created_at: str = None, created_by: 'User' = None, updated_at: str = None, updated_by: 'User' = None, contact_type: str = None, contact: 'User' = None, status: str = None, severity: float = None, support_tier: str = None, resolution: str = None, close_notes: str = None, eu: 'Eu' = None, watchlist: List['User'] = None, attachments: List['Attachment'] = None, offering: 'Offering' = None, resources: List['Resource'] = None, comments: List['Comment'] = None) -> None:
        """
        Initialize a Case object.

        :param str number: (optional) Number/ID of the case.
        :param str short_escription: (optional) A short description of what the
               case is about.
        :param str description: (optional) A full description of what the case is
               about.
        :param str created_at: (optional) Date time of case creation in UTC.
        :param User created_by: (optional) Case creator.
        :param str updated_at: (optional) Date time of the last update on the case
               in UTC.
        :param User updated_by: (optional) Person who makes the most recent update
               to the case.
        :param str contact_type: (optional) Name of the console to interact with
               the contact.
        :param User contact: (optional) Person who reported the case.
        :param str status: (optional) Status of the case.
        :param float severity: (optional) The severity of the case.
        :param str support_tier: (optional) Support tier of the account.
        :param str resolution: (optional) Standard reasons of resolving case.
        :param str close_notes: (optional) Notes of case closing.
        :param Eu eu: (optional) Specifies if the case should be treated as EU
               regulated.
        :param List[User] watchlist: (optional) User IDs in the watchlist.
        :param List[Attachment] attachments: (optional) List of attachments/files
               of the case.
        :param Offering offering: (optional) A catalog offering associated with a
               case.
        :param List[Resource] resources: (optional) List of attached resources.
        :param List[Comment] comments: (optional) List of comments/updates sorted
               in chronological order.
        """
        self.number = number
        self.short_escription = short_escription
        self.description = description
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.contact_type = contact_type
        self.contact = contact
        self.status = status
        self.severity = severity
        self.support_tier = support_tier
        self.resolution = resolution
        self.close_notes = close_notes
        self.eu = eu
        self.watchlist = watchlist
        self.attachments = attachments
        self.offering = offering
        self.resources = resources
        self.comments = comments

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Case':
        """Initialize a Case object from a json dictionary."""
        args = {}
        if 'number' in _dict:
            args['number'] = _dict.get('number')
        if 'short_escription' in _dict:
            args['short_escription'] = _dict.get('short_escription')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'created_at' in _dict:
            args['created_at'] = _dict.get('created_at')
        if 'created_by' in _dict:
            args['created_by'] = User.from_dict(_dict.get('created_by'))
        if 'updated_at' in _dict:
            args['updated_at'] = _dict.get('updated_at')
        if 'updated_by' in _dict:
            args['updated_by'] = User.from_dict(_dict.get('updated_by'))
        if 'contact_type' in _dict:
            args['contact_type'] = _dict.get('contact_type')
        if 'contact' in _dict:
            args['contact'] = User.from_dict(_dict.get('contact'))
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        if 'severity' in _dict:
            args['severity'] = _dict.get('severity')
        if 'support_tier' in _dict:
            args['support_tier'] = _dict.get('support_tier')
        if 'resolution' in _dict:
            args['resolution'] = _dict.get('resolution')
        if 'close_notes' in _dict:
            args['close_notes'] = _dict.get('close_notes')
        if 'eu' in _dict:
            args['eu'] = Eu.from_dict(_dict.get('eu'))
        if 'watchlist' in _dict:
            args['watchlist'] = [User.from_dict(x) for x in _dict.get('watchlist')]
        if 'attachments' in _dict:
            args['attachments'] = [Attachment.from_dict(x) for x in _dict.get('attachments')]
        if 'offering' in _dict:
            args['offering'] = Offering.from_dict(_dict.get('offering'))
        if 'resources' in _dict:
            args['resources'] = [Resource.from_dict(x) for x in _dict.get('resources')]
        if 'comments' in _dict:
            args['comments'] = [Comment.from_dict(x) for x in _dict.get('comments')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Case object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'number') and self.number is not None:
            _dict['number'] = self.number
        if hasattr(self, 'short_escription') and self.short_escription is not None:
            _dict['short_escription'] = self.short_escription
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = self.created_at
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by.to_dict()
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = self.updated_at
        if hasattr(self, 'updated_by') and self.updated_by is not None:
            _dict['updated_by'] = self.updated_by.to_dict()
        if hasattr(self, 'contact_type') and self.contact_type is not None:
            _dict['contact_type'] = self.contact_type
        if hasattr(self, 'contact') and self.contact is not None:
            _dict['contact'] = self.contact.to_dict()
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status
        if hasattr(self, 'severity') and self.severity is not None:
            _dict['severity'] = self.severity
        if hasattr(self, 'support_tier') and self.support_tier is not None:
            _dict['support_tier'] = self.support_tier
        if hasattr(self, 'resolution') and self.resolution is not None:
            _dict['resolution'] = self.resolution
        if hasattr(self, 'close_notes') and self.close_notes is not None:
            _dict['close_notes'] = self.close_notes
        if hasattr(self, 'eu') and self.eu is not None:
            _dict['eu'] = self.eu.to_dict()
        if hasattr(self, 'watchlist') and self.watchlist is not None:
            _dict['watchlist'] = [x.to_dict() for x in self.watchlist]
        if hasattr(self, 'attachments') and self.attachments is not None:
            _dict['attachments'] = [x.to_dict() for x in self.attachments]
        if hasattr(self, 'offering') and self.offering is not None:
            _dict['offering'] = self.offering.to_dict()
        if hasattr(self, 'resources') and self.resources is not None:
            _dict['resources'] = [x.to_dict() for x in self.resources]
        if hasattr(self, 'comments') and self.comments is not None:
            _dict['comments'] = [x.to_dict() for x in self.comments]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Case object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Case') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Case') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    
    class ContactTypeEnum(Enum):
        """
        Name of the console to interact with the contact.
        """
        CLOUD_SUPPORT_CENTER = "Cloud Support Center"
        IMS_CONSOLE = "IMS Console"

    
    class SupportTierEnum(Enum):
        """
        Support tier of the account.
        """
        FREE = "Free"
        BASIC = "Basic"
        STANDARD = "Standard"
        PREMIUM = "Premium"


class CaseCollection():
    """
    a collection of cases returned by the `get_cases` operation.

    :attr int total_count: (optional) Total number of cases satisfying the query.
    :attr PaginationLink first: (optional) the first page of the case collection.
    :attr PaginationLink next: (optional) the next page of the case collection.
    :attr PaginationLink previous: (optional) the previous page of the case
          collection.
    :attr PaginationLink last: (optional) the last page of the case collection.
    :attr List[Case] cases: (optional) the cases returned in the collection.
    """

    def __init__(self, *, total_count: int = None, first: 'PaginationLink' = None, next: 'PaginationLink' = None, previous: 'PaginationLink' = None, last: 'PaginationLink' = None, cases: List['Case'] = None) -> None:
        """
        Initialize a CaseCollection object.

        :param int total_count: (optional) Total number of cases satisfying the
               query.
        :param PaginationLink first: (optional) the first page of the case
               collection.
        :param PaginationLink next: (optional) the next page of the case
               collection.
        :param PaginationLink previous: (optional) the previous page of the case
               collection.
        :param PaginationLink last: (optional) the last page of the case
               collection.
        :param List[Case] cases: (optional) the cases returned in the collection.
        """
        self.total_count = total_count
        self.first = first
        self.next = next
        self.previous = previous
        self.last = last
        self.cases = cases

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CaseCollection':
        """Initialize a CaseCollection object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'first' in _dict:
            args['first'] = PaginationLink.from_dict(_dict.get('first'))
        if 'next' in _dict:
            args['next'] = PaginationLink.from_dict(_dict.get('next'))
        if 'previous' in _dict:
            args['previous'] = PaginationLink.from_dict(_dict.get('previous'))
        if 'last' in _dict:
            args['last'] = PaginationLink.from_dict(_dict.get('last'))
        if 'cases' in _dict:
            args['cases'] = [Case.from_dict(x) for x in _dict.get('cases')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CaseCollection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'first') and self.first is not None:
            _dict['first'] = self.first.to_dict()
        if hasattr(self, 'next') and self.next is not None:
            _dict['next'] = self.next.to_dict()
        if hasattr(self, 'previous') and self.previous is not None:
            _dict['previous'] = self.previous.to_dict()
        if hasattr(self, 'last') and self.last is not None:
            _dict['last'] = self.last.to_dict()
        if hasattr(self, 'cases') and self.cases is not None:
            _dict['cases'] = [x.to_dict() for x in self.cases]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CaseCollection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CaseCollection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CaseCollection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class Comment():
    """
    A comment or update associated with a case.

    :attr str value: (optional) The comment.
    :attr str added_at: (optional) Timestamp of when comment is added.
    :attr User added_by: (optional) The person who added the comment.
    """

    def __init__(self, *, value: str = None, added_at: str = None, added_by: 'User' = None) -> None:
        """
        Initialize a Comment object.

        :param str value: (optional) The comment.
        :param str added_at: (optional) Timestamp of when comment is added.
        :param User added_by: (optional) The person who added the comment.
        """
        self.value = value
        self.added_at = added_at
        self.added_by = added_by

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Comment':
        """Initialize a Comment object from a json dictionary."""
        args = {}
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        if 'added_at' in _dict:
            args['added_at'] = _dict.get('added_at')
        if 'added_by' in _dict:
            args['added_by'] = User.from_dict(_dict.get('added_by'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Comment object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        if hasattr(self, 'added_at') and self.added_at is not None:
            _dict['added_at'] = self.added_at
        if hasattr(self, 'added_by') and self.added_by is not None:
            _dict['added_by'] = self.added_by.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Comment object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Comment') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Comment') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class DeleteFileResponse():
    """
    The response returned by the `delete_file` operation.

    :attr List[Attachment] attachments: (optional) List of attachments/files of the
          case.
    """

    def __init__(self, *, attachments: List['Attachment'] = None) -> None:
        """
        Initialize a DeleteFileResponse object.

        :param List[Attachment] attachments: (optional) List of attachments/files
               of the case.
        """
        self.attachments = attachments

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'DeleteFileResponse':
        """Initialize a DeleteFileResponse object from a json dictionary."""
        args = {}
        if 'attachments' in _dict:
            args['attachments'] = [Attachment.from_dict(x) for x in _dict.get('attachments')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a DeleteFileResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'attachments') and self.attachments is not None:
            _dict['attachments'] = [x.to_dict() for x in self.attachments]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this DeleteFileResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'DeleteFileResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'DeleteFileResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class Eu():
    """
    Specifies if the case should be treated as EU regulated.

    :attr bool support: (optional) Identifying whether the case has EU Support.
    :attr str data_center: (optional) Information about the data center.
    """

    def __init__(self, *, support: bool = None, data_center: str = None) -> None:
        """
        Initialize a Eu object.

        :param bool support: (optional) Identifying whether the case has EU
               Support.
        :param str data_center: (optional) Information about the data center.
        """
        self.support = support
        self.data_center = data_center

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Eu':
        """Initialize a Eu object from a json dictionary."""
        args = {}
        if 'support' in _dict:
            args['support'] = _dict.get('support')
        if 'data_center' in _dict:
            args['data_center'] = _dict.get('data_center')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Eu object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'support') and self.support is not None:
            _dict['support'] = self.support
        if hasattr(self, 'data_center') and self.data_center is not None:
            _dict['data_center'] = self.data_center
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Eu object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Eu') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Eu') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class EuPayload():
    """
    Specify if the case should be treated as EU regulated. Only one of the following
    properties is required. Call EU support utility endpoint to determine which property
    must be specified for your account.

    :attr bool supported: (optional) indicates whether the case should be treated as
          EU regulated.
    :attr int data_center: (optional) If EU supported utility endpoint specifies
          datacenter then pass the datacenter id to mark a case as EU supported.
    """

    def __init__(self, *, supported: bool = None, data_center: int = None) -> None:
        """
        Initialize a EuPayload object.

        :param bool supported: (optional) indicates whether the case should be
               treated as EU regulated.
        :param int data_center: (optional) If EU supported utility endpoint
               specifies datacenter then pass the datacenter id to mark a case as EU
               supported.
        """
        self.supported = supported
        self.data_center = data_center

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'EuPayload':
        """Initialize a EuPayload object from a json dictionary."""
        args = {}
        if 'supported' in _dict:
            args['supported'] = _dict.get('supported')
        if 'data_center' in _dict:
            args['data_center'] = _dict.get('data_center')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a EuPayload object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'supported') and self.supported is not None:
            _dict['supported'] = self.supported
        if hasattr(self, 'data_center') and self.data_center is not None:
            _dict['data_center'] = self.data_center
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this EuPayload object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'EuPayload') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'EuPayload') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class EuSupport():
    """
    information needed to treat a case as EU regulated.

    :attr str property: (optional) Property which must be specified on eu property
          of case creation payload.
    :attr List[object] values: (optional) If the value of property is 'datacenter'
          then select datacenter by passing its id in `eu.datacenter` field of case
          creation payload.
    """

    def __init__(self, *, property: str = None, values: List[object] = None) -> None:
        """
        Initialize a EuSupport object.

        :param str property: (optional) Property which must be specified on eu
               property of case creation payload.
        :param List[object] values: (optional) If the value of property is
               'datacenter' then select datacenter by passing its id in `eu.datacenter`
               field of case creation payload.
        """
        self.property = property
        self.values = values

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'EuSupport':
        """Initialize a EuSupport object from a json dictionary."""
        args = {}
        if 'property' in _dict:
            args['property'] = _dict.get('property')
        if 'values' in _dict:
            args['values'] = [object.from_dict(x) for x in _dict.get('values')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a EuSupport object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'property') and self.property is not None:
            _dict['property'] = self.property
        if hasattr(self, 'values') and self.values is not None:
            _dict['values'] = [x.to_dict() for x in self.values]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this EuSupport object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'EuSupport') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'EuSupport') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    
    class PropertyEnum(Enum):
        """
        Property which must be specified on eu property of case creation payload.
        """
        SUPPORTED = "supported"
        DATA_CENTER = "data_center"


class Offering():
    """
    A catalog offering associated with a case.

    :attr str id: (optional) id of the catalog offering.
    :attr str value: (optional) display name of the catalog offering.
    """

    def __init__(self, *, id: str = None, value: str = None) -> None:
        """
        Initialize a Offering object.

        :param str id: (optional) id of the catalog offering.
        :param str value: (optional) display name of the catalog offering.
        """
        self.id = id
        self.value = value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Offering':
        """Initialize a Offering object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Offering object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Offering object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Offering') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Offering') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class OfferingItem():
    """
    an individual offering.

    :attr str name: (optional) the name of the offering.
    :attr OfferingItemType type: (optional) the offering type.
    """

    def __init__(self, *, name: str = None, type: 'OfferingItemType' = None) -> None:
        """
        Initialize a OfferingItem object.

        :param str name: (optional) the name of the offering.
        :param OfferingItemType type: (optional) the offering type.
        """
        self.name = name
        self.type = type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'OfferingItem':
        """Initialize a OfferingItem object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'type' in _dict:
            args['type'] = OfferingItemType.from_dict(_dict.get('type'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a OfferingItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this OfferingItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'OfferingItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'OfferingItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class OfferingPayload():
    """
    The offering of a case to be created.

    :attr str name: Resource offering name.
    :attr OfferingPayloadType type: Resource offering type.
    """

    def __init__(self, name: str, type: 'OfferingPayloadType') -> None:
        """
        Initialize a OfferingPayload object.

        :param str name: Resource offering name.
        :param OfferingPayloadType type: Resource offering type.
        """
        self.name = name
        self.type = type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'OfferingPayload':
        """Initialize a OfferingPayload object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in OfferingPayload JSON')
        if 'type' in _dict:
            args['type'] = OfferingPayloadType.from_dict(_dict.get('type'))
        else:
            raise ValueError('Required property \'type\' not present in OfferingPayload JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a OfferingPayload object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this OfferingPayload object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'OfferingPayload') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'OfferingPayload') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class PaginationLink():
    """
    a reference to a page of results within a case collection.

    :attr str href: (optional) the page reference as a URI.
    """

    def __init__(self, *, href: str = None) -> None:
        """
        Initialize a PaginationLink object.

        :param str href: (optional) the page reference as a URI.
        """
        self.href = href

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PaginationLink':
        """Initialize a PaginationLink object from a json dictionary."""
        args = {}
        if 'href' in _dict:
            args['href'] = _dict.get('href')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PaginationLink object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'href') and self.href is not None:
            _dict['href'] = self.href
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PaginationLink object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PaginationLink') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PaginationLink') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ResolutionCode():
    """
    a resolution code.

    :attr float id: (optional) the resolution code identifier.
    :attr str value: (optional) the resolution code value.
    """

    def __init__(self, *, id: float = None, value: str = None) -> None:
        """
        Initialize a ResolutionCode object.

        :param float id: (optional) the resolution code identifier.
        :param str value: (optional) the resolution code value.
        """
        self.id = id
        self.value = value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResolutionCode':
        """Initialize a ResolutionCode object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResolutionCode object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResolutionCode object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResolutionCode') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResolutionCode') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class ResolutionCodesResponse():
    """
    the resolution codes returned by the `get_resolution_codes` operation.

    :attr List[ResolutionCode] resolution_codes: (optional) the set of supported
          resolution codes.
    """

    def __init__(self, *, resolution_codes: List['ResolutionCode'] = None) -> None:
        """
        Initialize a ResolutionCodesResponse object.

        :param List[ResolutionCode] resolution_codes: (optional) the set of
               supported resolution codes.
        """
        self.resolution_codes = resolution_codes

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResolutionCodesResponse':
        """Initialize a ResolutionCodesResponse object from a json dictionary."""
        args = {}
        if 'resolution_codes' in _dict:
            args['resolution_codes'] = [ResolutionCode.from_dict(x) for x in _dict.get('resolution_codes')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResolutionCodesResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'resolution_codes') and self.resolution_codes is not None:
            _dict['resolution_codes'] = [x.to_dict() for x in self.resolution_codes]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResolutionCodesResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResolutionCodesResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResolutionCodesResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class Resource():
    """
    a resource associated with a case.

    :attr str crn: (optional) Cloud Resource Name of the resource.
    :attr str name: (optional) Name of the resource.
    :attr str type: (optional) Only used to attach Classic IaaS devices which have
          no CRN.
    :attr int id: (optional) Only used to attach Classic IaaS devices which have no
          CRN. Id of Classic IaaS device.
    :attr str note: (optional) A note about this resource.
    """

    def __init__(self, *, crn: str = None, name: str = None, type: str = None, id: int = None, note: str = None) -> None:
        """
        Initialize a Resource object.

        :param str crn: (optional) Cloud Resource Name of the resource.
        :param str name: (optional) Name of the resource.
        :param str type: (optional) Only used to attach Classic IaaS devices which
               have no CRN.
        :param int id: (optional) Only used to attach Classic IaaS devices which
               have no CRN. Id of Classic IaaS device.
        :param str note: (optional) A note about this resource.
        """
        self.crn = crn
        self.name = name
        self.type = type
        self.id = id
        self.note = note

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Resource':
        """Initialize a Resource object from a json dictionary."""
        args = {}
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'note' in _dict:
            args['note'] = _dict.get('note')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Resource object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'note') and self.note is not None:
            _dict['note'] = self.note
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Resource object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Resource') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Resource') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class Status():
    """
    A status value used in case filtering.

    :attr str id: (optional) the status identifier.
    :attr str description: (optional) the status description.
    """

    def __init__(self, *, id: str = None, description: str = None) -> None:
        """
        Initialize a Status object.

        :param str id: (optional) the status identifier.
        :param str description: (optional) the status description.
        """
        self.id = id
        self.description = description

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Status':
        """Initialize a Status object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Status object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Status object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Status') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Status') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class StatusesResponse():
    """
    a collection of status values used in case filtering.

    :attr List[Status] statuses: (optional) the list of status values used incase
          filtering.
    """

    def __init__(self, *, statuses: List['Status'] = None) -> None:
        """
        Initialize a StatusesResponse object.

        :param List[Status] statuses: (optional) the list of status values used
               incase filtering.
        """
        self.statuses = statuses

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'StatusesResponse':
        """Initialize a StatusesResponse object from a json dictionary."""
        args = {}
        if 'statuses' in _dict:
            args['statuses'] = [Status.from_dict(x) for x in _dict.get('statuses')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a StatusesResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'statuses') and self.statuses is not None:
            _dict['statuses'] = [x.to_dict() for x in self.statuses]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this StatusesResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'StatusesResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'StatusesResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class TechnicalOfferingsResponse():
    """
    the response for the `get_technical_offerings` operation.

    :attr List[OfferingItem] offerings: (optional) a list of offerings.
    """

    def __init__(self, *, offerings: List['OfferingItem'] = None) -> None:
        """
        Initialize a TechnicalOfferingsResponse object.

        :param List[OfferingItem] offerings: (optional) a list of offerings.
        """
        self.offerings = offerings

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TechnicalOfferingsResponse':
        """Initialize a TechnicalOfferingsResponse object from a json dictionary."""
        args = {}
        if 'offerings' in _dict:
            args['offerings'] = [OfferingItem.from_dict(x) for x in _dict.get('offerings')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TechnicalOfferingsResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'offerings') and self.offerings is not None:
            _dict['offerings'] = [x.to_dict() for x in self.offerings]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TechnicalOfferingsResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TechnicalOfferingsResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TechnicalOfferingsResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other


class User():
    """
    information related to a user.

    :attr str name: (optional) Full name of the user.
    :attr str realm: (optional) the ID realm.
    :attr str user_id: (optional) unique user ID in the realm specified by the type.
    """

    def __init__(self, *, name: str = None, realm: str = None, user_id: str = None) -> None:
        """
        Initialize a User object.

        :param str name: (optional) Full name of the user.
        :param str realm: (optional) the ID realm.
        :param str user_id: (optional) unique user ID in the realm specified by the
               type.
        """
        self.name = name
        self.realm = realm
        self.user_id = user_id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'User':
        """Initialize a User object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'realm' in _dict:
            args['realm'] = _dict.get('realm')
        if 'user_id' in _dict:
            args['user_id'] = _dict.get('user_id')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a User object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'realm') and self.realm is not None:
            _dict['realm'] = self.realm
        if hasattr(self, 'user_id') and self.user_id is not None:
            _dict['user_id'] = self.user_id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this User object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'User') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'User') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    
    class RealmEnum(Enum):
        """
        the ID realm.
        """
        IBMID = "IBMid"
        SL = "SL"
        BSS = "BSS"


class UserIdAndRealm():
    """
    information related to a user.

    :attr str realm: the ID realm.
    :attr str user_id: unique user ID in the realm specified by the type.
    """

    def __init__(self, realm: str, user_id: str) -> None:
        """
        Initialize a UserIdAndRealm object.

        :param str realm: the ID realm.
        :param str user_id: unique user ID in the realm specified by the type.
        """
        self.realm = realm
        self.user_id = user_id

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UserIdAndRealm':
        """Initialize a UserIdAndRealm object from a json dictionary."""
        args = {}
        if 'realm' in _dict:
            args['realm'] = _dict.get('realm')
        else:
            raise ValueError('Required property \'realm\' not present in UserIdAndRealm JSON')
        if 'user_id' in _dict:
            args['user_id'] = _dict.get('user_id')
        else:
            raise ValueError('Required property \'user_id\' not present in UserIdAndRealm JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UserIdAndRealm object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'realm') and self.realm is not None:
            _dict['realm'] = self.realm
        if hasattr(self, 'user_id') and self.user_id is not None:
            _dict['user_id'] = self.user_id
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UserIdAndRealm object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UserIdAndRealm') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UserIdAndRealm') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    
    class RealmEnum(Enum):
        """
        the ID realm.
        """
        IBMID = "IBMid"
        SL = "SL"
        BSS = "BSS"


